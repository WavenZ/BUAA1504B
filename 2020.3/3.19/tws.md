> 2020/3/19 

## 1. C/C++ 基础知识
(1) malloc与new区别

> 1、new分配内存按照数据类型进行分配，malloc分配内存按照指定的大小分配；
>
> 2、new返回的是指定对象的指针，而malloc返回的是void*，因此malloc的返回值一般都需要进行类型转化。
>
> 3、new不仅分配一段内存，而且会调用构造函数，malloc不会。
>
> 4、new分配的内存要用delete销毁，malloc要用free来销毁；delete销毁的时候会调用对象的析构函数，而free则不会。
>
> 5、new是一个操作符可以重载，malloc是一个库函数。
>
> 6、malloc分配的内存不够的时候，可以用realloc扩容。扩容的原理？new没用这样操作。
>
> 7、new如果分配失败了会抛出bad_malloc的异常，而malloc失败了会返回NULL。
>
> 8、申请数组时： new[]一次分配所有内存，多次调用构造函数，搭配使用delete[]，delete[]多次调用析构函数，销毁数组中的每个对象。而malloc则只能sizeof(int) * n。

(2) 静态函数和虚函数的区别

> 静态函数在编译的时候就已经确定运行时机，虚函数在运行的时候动态绑定。虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销

## 2. 操作系统
(1) 互斥锁（mutex）机制，以及互斥锁和读写锁的区别

> 1、互斥锁和读写锁区别：
>
> 互斥锁：mutex，用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒。
>
> 读写锁：rwlock，分为读锁和写锁。处于读操作时，可以允许多个线程同时获得读操作。但是同一时刻只能有一个线程可以获得写锁。其它获取写锁失败的线程都会进入睡眠状态，直到写锁释放时被唤醒。 注意：写锁会阻塞其它读写锁。当有一个线程获得写锁在写时，读锁也不能被其它线程获取；写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）。适用于读取数据的频率远远大于写数据的频率的场合。
>
> 互斥锁和读写锁的区别：
>
> 1）读写锁区分读者和写者，而互斥锁不区分
>
> 2）互斥锁同一时间只允许一个线程访问该对象，无论读写；读写锁同一时间内只允许一个写者，但是允许多个读者同时读对象。
>
> 2、Linux的4种锁机制：
>
> 互斥锁：mutex，用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒
>
> 读写锁：rwlock，分为读锁和写锁。处于读操作时，可以允许多个线程同时获得读操作。但是同一时刻只能有一个线程可以获得写锁。其它获取写锁失败的线程都会进入睡眠状态，直到写锁释放时被唤醒。 注意：写锁会阻塞其它读写锁。当有一个线程获得写锁在写时，读锁也不能被其它线程获取；写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）。适用于读取数据的频率远远大于写数据的频率的场合。
>
> 自旋锁：spinlock，在任何时刻同样只能有一个线程访问对象。但是当获取锁操作失败时，不会进入睡眠，而是会在原地自旋，直到锁被释放。这样节省了线程从睡眠状态到被唤醒期间的消耗，在加锁时间短暂的环境下会极大的提高效率。但如果加锁时间过长，则会非常浪费CPU资源。
>
> RCU：即read-copy-update，在修改数据时，首先需要读取数据，然后生成一个副本，对副本进行修改。修改完成后，再将老数据update成新的数据。使用RCU时，读者几乎不需要同步开销，既不需要获得锁，也不使用原子指令，不会导致锁竞争，因此就不用考虑死锁问题了。而对于写者的同步开销较大，它需要复制被修改的数据，还必须使用锁机制同步并行其它写者的修改操作。在有大量读操作，少量写操作的情况下效率非常高。

(2)请你来说一说协程

> 1、概念：
>
> 协程，又称微线程，纤程，英文名Coroutine。协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。
>
> 例如：
>
> ```
> def A() :
> print '1'
> print '2'
> print '3'
> def B() :
> print 'x'
> print 'y'
> print 'z'
> ```
>
> 由协程运行结果可能是12x3yz。在执行A的过程中，可以随时中断，去执行B，B也可能在执行过程中中断再去执行A。但协程的特点在于是一个线程执行。
>
> 2）协程和线程区别
>
> 那和多线程比，协程最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。
>
> 第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。
>
> 3）其他
>
> 在协程上利用多核CPU呢——多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。
>
> Python对协程的支持还非常有限，用在generator中的yield可以一定程度上实现协程。虽然支持不完全，但已经可以发挥相当大的威力了。

## 3. 计算机网络
(1)  请介绍一下操作系统中的中断

> 中断是指CPU对系统发生的某个事件做出的一种反应，CPU暂停正在执行的程序，保存现场后自动去执行相应的处理程序，处理完该事件后再返回中断处继续执行原来的程序。中断一般三类，一种是由CPU外部引起的，如I/O中断、时钟中断，一种是来自CPU内部事件或程序执行中引起的中断，例如程序非法操作，地址越界、浮点溢出），最后一种是在程序中使用了系统调用引起的。而中断处理一般分为中断响应和中断处理两个步骤，中断响应由硬件实施，中断处理主要由软件实施。

(2) 请问server端监听端口，但还没有客户端连接进来，此时进程处于什么状态？

> 这个需要看服务端的编程模型，如果如上一个问题的回答描述的这样，则处于阻塞状态，如果使用了epoll,select等这样的io复用情况下，处于运行状态

## 4. 数据库
(1) 请你介绍一下mysql的MVCC机制

> MVCC是一种多版本并发控制机制，是MySQL的InnoDB存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。MVCC是通过保存数据在某个时间点的快照来实现该机制，其在每行记录后面保存两个隐藏的列，分别保存这个行的创建版本号和删除版本号，然后Innodb的MVCC使用到的快照存储在Undo日志中，该日志通过回滚指针把一个数据行所有快照连接起来。

(2) 请问SQL优化方法有哪些

> 通过建立索引对查询进行优化
>
> 对查询进行优化，应尽量避免全表扫描

## 5. 算法
(1) 对称二叉树

> 给定一个二叉树，检查它是否是镜像对称的。https://leetcode-cn.com/problems/symmetric-tree/
>
> ```C++
> class Solution {
> public:
>     bool isSymmetric(TreeNode* root) {
>          return isMirror(root,root);
>     }
>     bool isMirror(struct TreeNode *t1,struct TreeNode *t2)
> {
>     if(t1==NULL&&t2==NULL)   return true;
>     if(t1==NULL||t2==NULL)   return false;
>     return ((*t1).val == (*t2).val) && (isMirror((*t1).right, (*t2).left)) && (isMirror((*t1).left, (*t2).right));
> }
> };
> 
> ```

(2) 二叉树的层次遍历 II

> 给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/
>
> ```C++
> class Solution {
> public:
>     vector<vector<int>> levelOrderBottom(TreeNode* root) {
>         vector<vector<int>> ans;
>         if(!root)return ans;
>         queue<TreeNode*> q;
>         TreeNode* tmp = root;
>         q.push(tmp);
>         vector<int> path;
>         while(!q.empty())
>         {
>             int size = q.size();
>             
>             for(int i = 0; i < size; i++)
>             {
>                 tmp = q.front();
>                 path.push_back(tmp->val);
>                 q.pop();
>                 if(tmp->left)q.push(tmp->left);
>                 if(tmp->right)q.push(tmp->right);
>             }
>             ans.insert(ans.begin(),path);
>             path.clear();
>         }
>         return ans;
>     }   
> };
> ```
>
> 

