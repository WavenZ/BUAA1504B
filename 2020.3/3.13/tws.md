> 2020/3/13 第三天 坚持就是胜利

## 1. C/C++ 基础知识
(1) 多态能否用C语言实现？

> 多态（Polymorphism），是指面向对象程序运行时，相同的消息可能会送给多个不同的类之对象，而系统可依据对象所属类，引发对应类的方法，而有不同的行为。简单来说，所谓多态意指**相同的消息给予不同的对象会引发不同的动作**称之。C语言的继承和多态主要就是如何灵活运用C函数指针这一特性。
>
> [参考链接](https://blog.csdn.net/dai_jing/article/details/38232641)

(2) 区别指针函数和函数指针？ 

> 指针函数是函数，返回值为一个指针。声明形式：ret *func(args, ...);
>
> 函数指针是指针，指向函数的指针。声明形式：ret (p)(args, ...);  其中，ret为返回值，p作为一个整体，代表的是指向该函数的指针，args为形参列表。其中p被称为函数指针变量 。
>
> [参考链接](https://blog.csdn.net/u010280075/article/details/88914424)

## 2. 操作系统
(1) 什么是死锁？死锁产生的条件？

> 所谓死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。
>
> 产生死锁的必要条件：
>
> 互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。
> 请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。
> 不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。
> 环路等待条件：在发生死锁时，必然存在一个进程--资源的环形链。
> [参考链接](https://blog.csdn.net/hd12370/article/details/82814348)

(2) 进程有哪几种状态？

> 一般来说，进程有三个状态，即就绪状态，运行状态，阻塞状态。
>
> 运行态：进程占用CPU，并在CPU上运行； 
>
> 就绪态：进程已经具备运行条件，但是CPU还没有分配过来；
>
> 阻塞态：进程因等待某件事发生而暂时不能运行。
>
> [参考链接](https://www.cnblogs.com/zxf98/p/5716296.html)

## 3. 计算机网络
(1) GET 和 POST 的区别？

> 它们的本质都是 TCP 链接，并无区别。但是由于 HTTP 的规定以及浏览器/服务器的限制，导致它们在应用过程中可能会有所不同。
>
> [参考链接](https://blog.csdn.net/qq_38182125/article/details/89071899)

(2) 为什么要三次握手、四次挥手？  

> 三次握手是为了建立可靠的连接。注意可靠这两个字。四次挥手是为了可靠的关闭连接，同样注意可靠这两个字。
>
> [参考链接](https://www.cnblogs.com/liuyu7177/p/11428914.html)

## 4. 数据库
(1) 什么是脏读？什么是幻读？

> 脏读是指当一个事务正在访问数据，并且对数据进行了修改。而这种修改还没有提交到数据库中，这时，另外一个事务也访问了这个数据，然后使用了这个数据。
>
> 幻读是指当事务不是独立执行时发生的一种现象。例如第一个事务对一个表中的数据进行了修改，这种修改涉及到了表中的全部数据行。同时，第二个事务也修改了这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好像发生了幻觉一样。

(2) 第一范式、第二范式、第三范式分别是什么？

> 1NF的定义为：符合1NF的关系中的每个属性都不可再分。
>
> 2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖。
>
> 3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖。
>
> [参考链接](https://blog.csdn.net/wenco1/article/details/88077279)

## 5. 算法
(1) 反转一个单链表

示例:

> 输入: 1->2->3->4->5->NULL  
> 输出: 5->4->3->2->1->NULL

```c++
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        //if((head==NULL)||(head->next=NULL)) return head;
        
        ListNode* pre=NULL;
        ListNode* cur=head;
        ListNode* temp;
        while(cur!=NULL){
            temp=cur->next; //temp存放当前结点的下一结点的地址
            cur->next=pre; //当前结点指向前一个结点
            pre=cur;   //pre往前走一个结点
            cur=temp;  //cur也走到下一个结点
            //重复上述步骤
        }
        return pre;  //最后pre走到正向的最后一个结点，即反向链表的第一个结点，所以返回pre
    }
};
```

(2) 一个数组中，找出除最大值之外的最大的k个数。 