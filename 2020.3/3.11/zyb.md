####
	1.语言基础知识
	(1) static关键字的作用？
		Java中：
			static修饰的非private成员（属性和方法），即便不new出对象，也可以通过类名的方式来访问.
			static修饰属性：此属性属于类本身，被类的所有对象共用.
			static修饰方法：静态方法不能访问非静态成员（new出对象后非静态成员才存在于内存），非静态方法可以访问静态成员.
		C中：
			static全局变量和普通全局变量的区别：
				非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。
				而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。
			static局部变量和普通局部变量的区别：
				局部变量改变为静态局部变量后是改变了它的存储方式（改变了它的生存期）.
			static函数和普通函数的区别：
				 static函数与普通函数作用域不同,仅在本源文件。
				 只在当前源文件中使用的函数应该说明为内部函数(static修饰的函数)。
####
	2.操作系统
	(1) 进程与线程的区别？
		进程：操作系统中正在运行着的应用程序，进程是资源分配的最小单位。
		线程：一个程序中不同的执行路径。简单来说：我们以前编写的程序都有一个入口、一个出口以及一个顺序执行的序列，
			  在程序执行过程中的任何指定时刻，都只有一个单独的执行点。事实上，在单个程序内部是可以在同一时刻进行多种
			  运算的，也就是多线程。
		线程是进程中的一部分，进程包含多个线程。
		在Java中使用aa.start()开始一个新的进程，执行代码是aa对象中的run()方法。
	(2) 进程间通信有那些方式？它们的区别？
		进程间通讯方式有：管道，信号量，消息队列，共享内存，套接字等
			管道：管道分为有名管道和无名管道，其中无名管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用，一般用于两个不同进程之间的通信。
				  有名管道也是一种半双工的通信方式，但它允许无亲缘关系进程间的通信。
			信号量：信号量是一个计数器，可以用来控制多个线程对共享资源的访问，它不是用于交换大批数据，而用于多线程之间的同步与互斥。他常作为一种锁机制。
				  因此，主要作为进程间以及同一个进程内不同线程之间的同步手段。
			消息队列：消息队列是消息的链表，存放在内核中并由消息队列标识符标识，消息队列克服了信号传递信息少，管道只能承无格式字节流以及缓冲区大小受限等特点。
			共享内存：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。
			      往往与其他通信机制，如信号量配合使用，来实现进程间的同步和通信。
			套接字：套接字可用于不同及其间的进程通信。流式套接字：提供可靠的，面向连接的通讯流；
                  数据包套接字：定义一种无连接的服务，通过相互独立的报文进行传输，是无序的；原始套接字：用于新的网络协议的测试
			参考自（https://blog.csdn.net/xiaonan153/article/details/81502245）
####
	3.计算机网络
	(1) Http和Https的区别？
		1) https协议需要到ca申请证书，一般免费证书很少，需要交费。
		2) http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议(当然不是绝对安全)。
		3) http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
		4) http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。
	(2) 三次握手与四次挥手
		1) 三次握手
			C:喂,你好 -> S:你好 -> C:S,我听到你说"你好"了
		2) 四次挥手
			F:分手！ -> M:好 -> M:确定分吗？ -> F:是！
			(口是心非的女人又等了四分钟，唉。。。不予置评)
####
	4.数据库
	(1) 事务的四大特征？
		原子性： 指事务包含的所有操作要么全部成功，要么全部失败回滚，如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。
		一致性： 指在事务执行前后，整个数据库处于某种一致状态，保持数据的完整性。
		隔离性： 指当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。
	    持久性： 指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。
		(参考亚军提供的博客)
	(2) 数据库的隔离级别
		1) 读未提交的 Read uncommitted ：最低级别，任何情况都无法保证
		2) 读已提交的 Read committed ：可避免脏读的发生
		3) 可以重复读 Repeatable read ：可避免脏读、不可重复读的发生
		4) 串行化     Serializable ：可避免脏读、不可重复读、幻读的发生   
		从上到下隔离级别越高，性能越差。
####
	5.剑指offer
	(1) 链表的倒数第 k 个节点
		题目：输入一个链表，输出该链表中倒数第 k 个节点。为了符合大多数人的习惯，本题从 1 开始计数，即链表的尾节点是倒数第 1 个节点。
		例如，一个链表有 6 个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。
		链表节点定义如下：
#include <stdio.h>
#include <malloc.h>

typedef struct node
{
    int data;
    struct node *next;
}NODE, *PNODE;

int main()
{
    int count, pos, i;
    PNODE head, cur, tmp;

    while (scanf("%d %d", &count, &pos) != EOF)
    {
        if (pos > count)
            pos = 0;
        head = (PNODE)malloc(sizeof(NODE));
        scanf("%d", &(head->data));
        cur = head;
        for (i = 0; i < count-1; i++)
        {
            cur->next = (PNODE)malloc(sizeof(struct node));
            cur = cur->next;
            scanf("%d", &(cur->data));
        }
        cur->next = NULL;
        tmp = cur = head;
        for (i = 0; i < pos && tmp != NULL; i++)
        {
            tmp = tmp->next;
        }
        while (tmp)
        {
            cur = cur->next;
            tmp = tmp->next;
        }
        if (cur)
            printf("%d\n", cur->data);
        else
            printf("NULL\n");
        while (head)
        {
            cur = head;
            head = head->next;
            free(cur);
        }
    }
    return 0;
}
		
	
	(2) 股票最大利润
		假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？
		例如，已知股票在某些时间节点的价格为 {9, 11, 8, 5, 7, 12, 16, 14}。
		如果我们能在价格为 5 的时候买入并在价格为 16 时卖出，则能收货最大的利润 11。
		