> 2020/3/14若有恒，何必三更起五更眠；最无益，莫过一日曝十日寒

## 1. C/C++ 基础知识
(1) 下列程序编译时，（1）（2）（3）（4）（5）中有语法错误的语句是

```
#include<iostream>
#include<string>
using namespace std; 
class Pet
{
     string name;
public:
     Pet(string p=" "){name=p;}
      string getName()const {return name;}
     virtual void call()const=0;
}; 
class Dog: public Pet{
public:
Dog(string n):Pet(n){}
void call()const{cout<<"##"<<" ";}
};
class Cat:public Pet{
public:
Cat(string n):Pet(n){}
void call()const{cout<<"**";}
};
void f(Pet *p)
{p->call();}
int main()
{ 
Pet pet0("#");           	//(1)
Dog pet1("*");           	//(2)
Cat pet2("$");           	//(3)
f(&pet1);					//(4)
f(&pet2);					//(5)
return 0;
}
```

> (1)     Pet 是一个抽象类，所以不能用来实例化对象，只能作为接口被调用

(2) 请说一下C/C++ 中指针和引用的区别？

> 1.指针有自己的一块空间，而引用只是一个别名；
> 2.使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；
>
> 3.指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象 的引用；
>
> 4.作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象；
>
> 5.可以有const指针，但是没有const引用；
>
> 6.指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；
>
> 7.指针可以有多级指针（**p），而引用至于一级；
>
> 8.指针和引用使用++运算符的意义不一样；
>
> 9.如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。

## 2. 操作系统
(1) 操作系统中的缺页中断

> malloc()和mmap()等内存分配函数，在分配时只是建立了进程虚拟地址空间，并没有分配虚拟内存对应的物理内存。当进程访问这些没有建立映射关系的虚拟内存时，处理器自动触发一个缺页异常。
> 缺页中断：在请求分页系统中，可以通过查询页表中的状态位来确定所要访问的页面是否存在于内存中。每当所要访问的页面不在内存是，会产生一次缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存。
>
> 缺页本身是一种中断，与一般的中断一样，需要经过4个处理步骤：
>
> 1、保护CPU现场
>
> 2、分析中断原因
>
> 3、转入缺页中断处理程序进行处理
>
> 4、恢复CPU现场，继续执行
>
> 但是缺页中断是由于所要访问的页面不存在于内存时，由硬件所产生的一种特殊的中断，因此，与一般的中断存在区别：
>
> 1、在指令执行期间产生和处理缺页中断信号
>
> 2、一条指令在执行期间，可能产生多次缺页中断
>
> 3、缺页中断返回是，执行产生中断的一条指令，而一般的中断返回是，执行下一条指令。

(2) 操作系统中的结构体对齐，字节对齐

> 1、原因：
> 1）平台原因（移植原因）：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。
>
> 2）性能原因：数据结构（尤其是栈）应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。
>
> 2、规则
>
> 1）数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员的对齐按照#pragma pack指定的数值和这个数据成员自身长度中，比较小的那个进行。
>
> 2）结构(或联合)的整体对齐规则：在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。
>
> 3）结构体作为成员：如果一个结构里有某些结构体成员，则结构体成员要从其内部最大元素大小的整数倍地址开始存储。
>
> 3、定义结构体对齐
>
> 可以通过预编译命令#pragma pack(n)，n=1,2,4,8,16来改变这一系数，其中的n就是指定的“对齐系数”。
>
> 4、举例
>
> #pragma pack(2)
>
> struct AA {
>
> int a;       //长度4 > 2 按2对齐；偏移量为0；存放位置区间[0,3]
>
> char b;  //长度1 < 2 按1对齐；偏移量为4；存放位置区间[4]
>
> short c;     //长度2 = 2 按2对齐；偏移量要提升到2的倍数6；存放位置区间[6,7]
>
> char d;  //长度1 < 2 按1对齐；偏移量为7；存放位置区间[8]；共九个字节
>
> };
>
> #pragma pack()

## 3. 计算机网络
(1) 搜索baidu，会用到计算机网络中的什么层？每层是干什么的

> 浏览器中输入URL
> 浏览器要将URL解析为IP地址，解析域名就要用到DNS协议，首先主机会查询DNS的缓存，如果没有就给本地DNS发送查询请求。DNS查询分为两种方式，一种是递归查询，一种是迭代查询。如果是迭代查询，本地的DNS服务器，向根域名服务器发送查询请求，根域名服务器告知该域名的一级域名服务器，然后本地服务器给该一级域名服务器发送查询请求，然后依次类推直到查询到该域名的IP地址。DNS服务器是基于UDP的，因此会用到UDP协议。
>
>
> 得到IP地址后，浏览器就要与服务器建立一个http连接。因此要用到http协议，http协议报文格式上面已经提到。http生成一个get请求报文，将该报文传给TCP层处理，所以还会用到TCP协议。如果采用https还会使用https协议先对http数据进行加密。TCP层如果有需要先将HTTP数据包分片，分片依据路径MTU和MSS。TCP的数据包然后会发送给IP层，用到IP协议。IP层通过路由选路，一跳一跳发送到目的地址。当然在一个网段内的寻址是通过以太网协议实现(也可以是其他物理层协议，比如PPP，SLIP)，以太网协议需要直到目的IP地址的物理地址，有需要ARP协议。
>
> 其中：
>
> 1、DNS协议，http协议，https协议属于应用层
>
> 应用层是体系结构中的最高层。应用层确定进程之间通信的性质以满足用户的需要。这里的进程就是指正在运行的程序。应用层不仅要提供应用进程所需要的信息交换和远地操作，而且还要作为互相作用的应用进程的用户代理，来完成一些为进行语义上有意义的信息交换所必须的功能。应用层直接为用户的应用进程提供服务。
>
> 2、TCP/UDP属于传输层
>
> 传输层的任务就是负责主机中两个进程之间的通信。因特网的传输层可使用两种不同协议：即面向连接的传输控制协议TCP，和无连接的用户数据报协议UDP。面向连接的服务能够提供可靠的交付，但无连接服务则不保证提供可靠的交付，它只是“尽最大努力交付”。这两种服务方式都很有用，备有其优缺点。在分组交换网内的各个交换结点机都没有传输层。
>
> 3、IP协议，ARP协议属于网络层
>
> 网络层负责为分组交换网上的不同主机提供通信。在发送数据时，网络层将运输层产生的报文段或用户数据报封装成分组或包进行传送。在TCP/IP体系中，分组也叫作IP数据报，或简称为数据报。网络层的另一个任务就是要选择合适的路由，使源主机运输层所传下来的分组能够交付到目的主机。
> 4、数据链路层
>
> 当发送数据时，数据链路层的任务是将在网络层交下来的IP数据报组装成帧，在两个相邻结点间的链路上传送以帧为单位的数据。每一帧包括数据和必要的控制信息（如同步信息、地址信息、差错控制、以及流量控制信息等）。控制信息使接收端能够知道—个帧从哪个比特开始和到哪个比特结束。控制信息还使接收端能够检测到所收到的帧中有无差错。
> 5、物理层
>
> 物理层的任务就是透明地传送比特流。在物理层上所传数据的单位是比特。传递信息所利用的一些物理媒体，如双绞线、同轴电缆、光缆等，并不在物理层之内而是在物理层的下面。因此也有人把物理媒体当做第0层。

(2) 数字证书是什么，里面都包含那些内容

> 1）概念：
> 数字证书是数字证书在一个身份和该身份的持有者所拥有的公/私钥对之间建立了一种联系，由认证中心（CA）或者认证中心的下级认证中心颁发的。根证书是认证中心与用户建立信任关系的基础。在用户使用数字证书之前必须首先下载和安装。
>
> 认证中心是一家能向用户签发数字证书以确认用户身份的管理机构。为了防止数字凭证的伪造，认证中心的公共密钥必须是可靠的，认证中心必须公布其公共密钥或由更高级别的认证中心提供一个电子凭证来证明其公共密钥的有效性，后一种方法导致了多级别认证中心的出现。
>
> 2）数字证书颁发过程：
>
> 数字证书颁发过程如下：用户产生了自己的密钥对，并将公共密钥及部分个人身份信息传送给一家认证中心。认证中心在核实身份后，将执行一些必要的步骤，以确信请求确实由用户发送而来，然后，认证中心将发给用户一个数字证书，该证书内附了用户和他的密钥等信息，同时还附有对认证中心公共密钥加以确认的数字证书。当用户想证明其公开密钥的合法性时，就可以提供这一数字证书。
>
> 3）内容：
>
> 数字证书的格式普遍采用的是X.509V3国际标准，一个标准的X.509数字证书包含以下一些内容：
>
> 1、证书的版本信息；
>
> 2、证书的序列号，每个证书都有一个唯一的证书序列号；
>
> 3、证书所使用的签名算法；
>
> 4、证书的发行机构名称，命名规则一般采用X.500格式；
>
> 5、证书的有效期，通用的证书一般采用UTC时间格式；
>
> 6、证书所有人的名称，命名规则一般采用X.500格式；
>
> 7、证书所有人的公开密钥；
>
> 8、证书发行者对证书的签名。

## 4. 数据库
(1) 索引是什么，多加索引一定会好吗

> 1、索引
> 数据库索引是为了增加查询速度而对表字段附加的一种标识，是对数据库表中一列或多列的值进行排序的一种结构。
>
> DB在执行一条Sql语句的时候，默认的方式是根据搜索条件进行全表扫描，遇到匹配条件的就加入搜索结果集合。如果我们对某一字段增加索引，查询时就会先去索引列表中一次定位到特定值的行数，大大减少遍历匹配的行数，所以能明显增加查询的速度。
>
> 优点：
>
> 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
>
> 可以大大加快数据的检索速度，这也是创建索引的最主要的原因。
>
> 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。
>
> 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。
>
> 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。
>
> 缺点：
>
> 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。
>
> 索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。
>
> 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。
>
> 2、添加索引原则
>
> 在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。
>
> 只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。
>
> 定义为text、image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。
>
> 当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。

(2) 请你说一说inner join和left join

> left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录 right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录
> inner join(等值连接) 只返回两个表中联结字段相等的行

## 5. 算法
(1) 求1+2+…+n [Leetcode链接](https://leetcode-cn.com/problems/qiu-12n-lcof/)  
> 求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。  限制：1 <= n <= 10000  
> 示例:
```c
输入: n = 3
输出: 6
输入: n = 9
输出: 45
```

```c++
class Solution {
public:
    int sumNums(int n) {
         int ans = n;
        ans && (ans += sumNums(n - 1));//利用&&短路特性进行条件判断
        return ans;

    }
};
```

(2) 两数相加 [Leetcode链接](https://leetcode-cn.com/problems/add-two-numbers)

> 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。   
>
> 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。
>
> 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。  
> 示例:
```c
输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
输出：7 -> 0 -> 8
原因：342 + 465 = 807
```

```C++
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* l3 = new ListNode(-1);
		ListNode* hl3 = l3;
		int c = 0, end1 = 0, end2 = 0;
		while (end1 == 0 || end2 == 0 || c == 1)
		{
			l3->val = (l1->val + l2->val + c) % 10;
			c = (l1->val + l2->val + c) / 10;
			if (l1->next == NULL) l1->val = 0,end1=1; else l1 = l1->next;
			if (l2->next == NULL) l2->val = 0,end2=1; else l2 = l2->next;
			if (end1 == 0 || end2 == 0 || c == 1)
			{ 
				l3->next = new ListNode(-1);
				l3 = l3->next;
			}
		}
		return hl3;
    }
};
```

