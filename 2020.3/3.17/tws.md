> 2020/3/17 go go go

## 1. C/C++ 基础知识
(1) 在linux系统下使用gcc编译c++，若程序跑挂了怎么找到程序里面的问题？

> 1. 检查程序中是否存在访问错误（数组越界，空指针等）、堆栈溢出等常见错误。
> 2. 可以通过gdb调试或者利用打印信息来定位程序跑飞的位置。
> 3. 如果有core生成，利用gdb来分析core文件找到跑飞的原因。

(2) 接上一问，有没有办法把出错的现场保留下来，然后事后去定位问题？

> 编译程序时打开-g参数，当程序崩溃时会产生core文件，core文件会包含程序运行时的内存，寄存器状态、堆栈指针，内存管理信息还有各种堆栈信息等。通过分析core可以定位到程序产生异常时的堆栈信息，从而找到出现问题的代码。

## 2. 操作系统
(1) linux下什么命令可以查看所有进程？

> 1. ps命令：运用该命令可以确定有哪些进程正在运行和运行状态、进程是否结束、进程是否僵死、进程占用系统资源等信息。
> 2. top命令：top命令可以是实时显示各个进程状况。
> 3. pstree命令：pstree命令以树状图的方式展现进程之间的派生关系。
> 4. pgrep命令：pgrep命令以名称为一句从运行队列中查找进程，并显示查找到的进程id。

(2) 常见的Linux命令：查看程序占用多少内存？https://www.cnblogs.com/laoqing/p/7718607.html

> 方法一：
>
> 1. 首先利用`ps -ef | grep name`查找到进程name的进程id。
> 2. 再利用`top -p id`命令查看内存。
>
> 方法二：
>
> 1. `ps -aux | grep 进程名`。
>
> 方法三：
>
> 1. `cat /proc/进程号/status`。

## 3. 计算机网络
(1) 什么场景下比较适合UDP协议？

> UDP一般用于即时通信（QQ聊天 对数据准确性和丢包要求比较低，但速度必须快），在线视频（RTSP 速度一定要快，保证视频连续，但是偶尔花了一个图像帧，人们还是能接受的），网络语音电话（VoIP 语音数据包一般比较小，需要高速发送，偶尔断音或串音也没有问题）等等。 

(2) TCP怎么样做流量控制？

> 流量控制：数据的传送与接收过程当中很可能出现收方来不及接收的情况,这时就需要对发方进行控制,以免数据丢失。流量控制用于防止在端口阻塞的情况下丢帧，这种方法是当发送或接收缓冲区开始溢出时通过将阻塞信号发送回源地址实现的。流量控制可以有效的防止由于网络中瞬间的大量数据对网络带来的冲击，保证用户网络高效而稳定的运行。
>
> 1.通信双方主机上都分别有一个“发送窗口”和一个“接受窗口”
> 2.TCP连接阶段，双方协商窗口尺寸
> 3.发送方根据协商的结果，发送符合窗口尺寸的数据字节流，并等待对方的确认，等待确认机制
> 4.发送方根据确认信息，改变窗口的尺寸

## 4. 数据库
(1) 请你说一说数据库索引

> 1、索引
>
> 数据库索引是为了增加查询速度而对表字段附加的一种标识，是对数据库表中一列或多列的值进行排序的一种结构。
>
> DB在执行一条Sql语句的时候，默认的方式是根据搜索条件进行全表扫描，遇到匹配条件的就加入搜索结果集合。如果我们对某一字段增加索引，查询时就会先去索引列表中一次定位到特定值的行数，大大减少遍历匹配的行数，所以能明显增加查询的速度。
>
> 优点：
>
> 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
>
> 可以大大加快数据的检索速度，这也是创建索引的最主要的原因。
>
> 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。
>
> 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。
>
> 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。
>
> 缺点：
>
> 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。
>
> 索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。
>
> 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。
>
> 2、添加索引原则
>
> 在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。
>
> 只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。
>
> 定义为text、image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。
>
> 当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。


(2) 多加索引一定会好吗？

> 不一定，如上题。

## 5. 算法
(1) 给你一个长度为N的无序数组，然后找出里面最大的K个数。

```C++
#include <stdio.h> 
#include <stdlib.h> 
#include <string.h> 
#include <algorithm> 
#include <queue> 
using namespace std; 
struct cmp{ 
   bool operator ()(int a,int b) 
   { 
       return a>b; 
   } 
}; 
#define MAX 11000 
int a[MAX]; 
using namespace std; 
priority_queue<int,vector<int>,cmp>q; 
int main() 
{ 
   int n,i,k,m,top; 
   scanf("%d%d",&n,&m); 
     for(i=1;i<=n;i++) 
     { 
          scanf("%d",&k); 
          if(i<=m)   //前m个数入 队列 
          { 
               q.push(k); 
               if(i==m)  //纪录前m个数中最小的数 
                    top=q.top(); 
          } 
          else 
          { 
               if(k>top)  //如果新加入的数大于队列中最小的数则出队 
               { 
                    q.pop(); 
                    q.push(k); 
                    top=q.top(); 
               } 
          } 
     } 
     k=0; 
     while(!q.empty())  //这样处理是为了最后一个数打印时没有空格 
     { 
          a[k++]=q.top(); 
          q.pop(); 
     } 
     for(i=0;i<k;i++) 
     { 
          printf("%d",a[i]); 
          if(i==k-1) 
               printf("\n"); 
          else 
               printf(" "); 
     } 
   return 0; 
}

```

(2) 爬楼梯问题，你可以一次爬1层或2层，如果有n层楼梯，一共有点多少种解法？。

最后一步走两阶或者一阶f(n)=f(n-1)+f(n-2)

```cpp
#include <iostream>
using namespace std;

int climbStairs(int n)
{
	if (n <= 1)
		return 1;
	if (n == 2)
		return 2;

	int p = 1;
	int q = 2;
	int curr;
	for (int i = 3; i <= n; ++i)
	{
		curr = p + q;
		p = q;
		q = curr;
	}

	return curr;
}

int main()
{
	int inputNum;
	cin >> inputNum;

	int result = climbStairs(inputNum);

	cout << result << endl;

	system("pause");
	return 0;
}

```

