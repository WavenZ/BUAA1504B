> 2020/3/18 加油

## 1. C/C++ 基础知识
(1) C语言中，局部变量能否和全局变量重名？

可以重名。程序中如果出现了相同的两个变量，一个是局部变量，一个是全局变量，编译可以通过，但程序会使用局部变量而不是全局变量，如果想使用全局变量的值，在全局变量之前加上“::”就可以。

(2) C语言中，指针的占几个字节？

64位操作系统的指针是8字节。

## 2. 操作系统
(1) linux中，文件硬链接和软链接有什么区别？

软链接类似于一个windows的快捷方式，硬链接文件与原文件属性完全相同，可随着原文件的变化而变化。  
硬链接不能跨分区，软链接可以跨分区。  
硬链接不可以针对目录使用，只针对文件；软链接可以针对目录使用。

(2) Linux中，查看系统所有进程命令，进程终止命令？

ps aux查看所有进程，根据进程号  
kill -9 PID 强制杀死进程

## 3. 计算机网络
(1) 对称加密与非对称加密？

对称加密是在加密和解密时使用同样的密钥，所以速度快，但是由于密钥要在网络中传输，所以安全性比较低。  
非对称密钥使用了一对密钥：公钥和私钥，信息发送者使用公钥进行加密，信息接受者使用私钥进行解密，所以安全性好，但是加密和解密速度都很慢。  
解决办法:发送方将对称加密的密钥使用非对称加密的公钥进行加密，然后发送出去，接收方使用私钥进行解密得到对称加密的密钥，然后双方可以使用对称加密来进行沟通。

(2) DDos攻击？

客户端向服务端发送请求连接数据包；服务端向客户端发送确认数据包；客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认。

## 4. 数据库
(1) 索引的底层实现原理和优化方法？

在数据结构中，我们最为常见的搜索结构就是二叉搜索树和AVL树(高度平衡的二叉搜索树，为了提高二叉搜索树的效率，减少树的平均搜索长度)了。然而，无论二叉搜索树还是AVL树，当数据量比较大时，都会由于树的深度过大而造成I/O读写过于频繁，进而导致查询效率低下，因此对于索引而言，多叉树结构成为不二选择。特别地，B-Tree的各种操作能使B树保持较低的高度，从而保证高效的查找效率。

(2) 索引的优点？

大大加快数据的检索速度；
加速表和表之间的连接；
在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间；
通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性；

## 5. 算法
(1) C或C++实现快速排序？
```c
# include <stdio.h>

int FindPos(int * a, int low, int high);//查找位置 
void QuickSort(int * a, int low, int high);//快速排序 

int main(void)
{
	int a[6] = {-2, 1, 0, -9, 4, -3};
	int i;

	QuickSort(a, 0, 5); //第二个参数表示第一个元素的下标  第三个参数表示最后一个元素的下标
	
	//显示排序效果 
	for (i=0; i<6; ++i)
		printf("%d  ", a[i]);
	printf("\n");

	return 0;
}

void QuickSort(int * a, int low, int high)//不需要返回值 
{
	int pos;

	if (low < high)
	{
		pos = FindPos(a, low, high);//找到第一个元素的位置 a是数组第一个元素的地址 
		QuickSort(a, low, pos-1); //左边一半按照同样的算法来排 
		QuickSort(a, pos+1, high);//右边一半按照同样的算法来排 
		//第一次运行时,
	}	
}

int FindPos(int * a, int low, int high)
{
	int val = a[low]; //low = 0；所以第一次查找的是第一个元素的位置 

	while (low < high)
	{
		while (low<high  && a[high]>=val)
			--high;
		a[low] = a[high];

		while (low<high && a[low]<=val)
			++low;
		a[high] = a[low];
	}//终止while循环之后low和high一定是相等的 

	a[low] = val; 

	return high; //high可以改为low, 但不能改为val 也不能改为a[low] 也不能改为a[high]
}
```

(2) C或C++实现冒泡排序？
```c
# include <stdio.h>

//冒泡排序
void sort(int * b, int len)
{
	int i, j, t;

	for (i=0; i<len-1; ++i)
	{
		for (j=0; j<len-1-i; ++j)
		{
			if (b[j] > b[j+1])  // >表示升序 <表示降序
			{
				t = b[j];
				b[j] = b[j+1];
				b[j+1] = t; 
			}
		}
	}
}

int main(void)
{
	int a[6] = {10, 2, 8, -8, 11, 0};
	int i = 0;

	sort(a, 6);

	for (i=0; i<6; ++i)
	{
		printf("%d ", a[i]);
	}
	printf("\n");

	return 0;
}
```
