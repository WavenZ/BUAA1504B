> 2020/3/12 第二天 坚持就是胜利

## 1. C/C++ 基础知识
(1) C++ 中空类对象sizeof的返回值是多少？为什么不能是0？

1   编译器插入了一个char用来表示类的不同对象，就是说空类同样可以实例化，每个实例都有一个独一无二的地址，为了达到这个目的，编译器会给空类隐含地加一个字节

(2) C++ 中多态是怎么实现的？

 虚函数，即在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数

## 2. 操作系统
(1) 扩容的时候内存用什么来分配？

(2) 怎么判断机器的大小端？

大端模式：数据高位字节保存在内存的低地址，低字节保存在内存的高地址；

小端模式：数据高位字节保存在内存的高地址，低字节保存在内存的地地址。

判断方式：

①指针判断：如将int类型指针强制转换为char类型指针，读取保存的一个字节数据，判断是否与原int类型数据第一个字节一致，一致则为小端，否则大端。

②联合体判断：利用联合体数据共享同一块地址空间的特点，在联合体内定义一个int变量和char变量，外部实例化时创建int变量，由char变量调用，相当于隐式类型转换，原理同上。

## 3. 计算机网络
(1) TCP、UDP区别？

1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接

2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。TCP通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。

3、UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。

4.每一条TCP连接只能是点到点的；UDP支持一对一、一对多、多对一和多对多的交互通信。

5、TCP对系统资源要求较多，UDP对系统资源要求较少。

(2) 网络里面为什么要有网络序的概念？是用来解决什么问题的？  

网络字节顺序是 TCP/IP 中规定好的一种数据表示格式，它与具体的 CPU 类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释。网络字节顺序采用 big endian 排序方式。

## 4. 数据库
(1) 什么是存储引擎？MySQL不同存储引擎间有什么区别？

存储引擎
1、存储引擎其实就是对于数据库文件的一种存取机制，如何实现存储数据，如何为存储的数据建立索引以及如何更新，查询数据等技术实现的方法。
2、MySQL中的数据用各种不同的技术存储在文件（或内存）中，这些技术中的每一种技术都使用不同的存储机制，索引技巧，锁定水平并且最终提供广泛的不同功能和能力。在MySQL中将这些不同的技术及配套的相关功能称为存储引擎。

区别

https://blog.csdn.net/qq_39387475/article/details/78217147

(2) 数据库mysql索引机制，为什么要用B+树？

数据库使用B+树肯定是为了提升查找效率。

查找数据，最简单的方式是顺序查找。但是对于几十万上百万，甚至上亿的数据库查询就很慢了。

所以要对查找的方式进行优化，熟悉的二分查找，二叉树可以把速度提升到O(log(n,2))，查询的瓶颈在于树的深度，最坏的情况要查找到二叉树的最深层，由于，每查找深一层，就要访问更深一层的索引文件。在多达数G的索引文件中，这将是很大的开销。所以，尽量把数据结构设计的更为‘矮胖’一点就可以减少访问的层数。在众多的解决方案中，B-/B+树很好的适合。B-树定义具体可以查阅，简而言之就是中间节点可以多余两个子节点，而且中间的元素可以是一个域。相比B-树，B+树的父节点也必须存在于子节点中，是其中最大或者最小元素，B+树的节点只存储索引key值，具体信息的地址存在于叶子节点的地址中。这就使以页为单位的索引中可以存放更多的节点。减少更多的I/O支出。因此，B+树成为了数据库比较优秀的数据结构，MySQL中MyIsAM和InnoDB都是采用的B+树结构。不同的是前者是非聚集索引，后者主键是聚集索引，所谓聚集索引是物理地址连续存放的索引，在取区间的时候，查找速度非常快，但同样的，插入的速度也会受到影响而降低。聚集索引的物理位置使用链表来进行存储。（引用自：https://www.cnblogs.com/tiancai/p/9024351.html）

## 5. 算法
(1) 反转字符串中的单词 III [Leetcode链接](https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/)  
> 给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。  
> 注意：在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。  
示例:
```c
输入: "Let's take LeetCode contest"
输出: "s'teL ekat edoCteeL tsetnoc" 
```

```c++
class Solution {
public:
    string reverseWords(string s) {
        string ans="";
        vector<string>str;
        string st = "";
        for(int i = 0; i < s.length(); i++) {
            if(s[i] != ' ')
                st += s[i];
            
            if(s[i] == ' '|| i == s.length()-1) {
                str.push_back(st);
                st = "";
                
            }
            
        }
        for(int i = 0; i < str.size(); i++) {
            for(int j = str[i].length() - 1; j >= 0; j--) {
                ans += str[i][j];
            }
            if(i !=  str.size()-1) {
                ans += " ";
            }
        }
        return ans;
    }
};
```

(2) 三色排序 [Leetcode链接](https://leetcode-cn.com/problems/sort-colors/)

> 给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。  
> 注意:
不能使用代码库中的排序函数来解决这道题。  
示例:
```c
输入: [2,0,2,1,1,0]
输出: [0,0,1,1,2,2]
```

```c++
class Solution {
public:
    void sortColors(vector<int>& nums) {
        vector<int> colors(3, 0);    // 记录每个颜色出现的次数
        for(int i=0; i<nums.size(); i++){  // 一次循环
            colors[nums[i]] += 1;
        }
        // 二次循环，进行排序，按照0，1，2排序
        int index = 0;
        for(int i=0; i<3; i++){
            while(colors[i]){ // 当数字减少到零，表示该颜色填充完毕
                nums[index] = i;
                colors[i]--;
                index++; 
            }
        }
    }
};
```

