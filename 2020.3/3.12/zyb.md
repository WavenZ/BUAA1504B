> 2020/3/12 第二天 坚持就是胜利

## 1. C/JAVA 基础知识
(1) JAVA中final关键字的作用？  

final修饰类：该类不能被继承  
final修饰类中静态属性：表示该属性必须被赋值（默认值不算真正的赋值）、且只能赋一次、不能修改。  
final修饰类中的方法：表示该方法可以被子类继承，但不能重写。

(2) JAVA 中多态是怎么实现的？ 

实现多态的语句：aa = bb。aa来自于A aa = new A()和B bb = new B()，A是B的父类。总结为：一个父类的引用类型的变量(aa)，它既可以指向父类对象也可以指向子类对象，它可以根据当前时刻指向的不同，自动调用不同对象的方法。

## 2. 操作系统
(1) 扩容的时候内存用什么来分配？

(2) 怎么判断机器的大小端？

大端模式：数据的低位保存在内存的高地址中，数据的高位保存在内存的低地址中。  
小端模式与大端模式相反。
  
判断大小端的方法：  
```c
#include <stdio.h>

int main ()
{
	short int a = 0x1122;//十六进制数 
	char b =  *(char *)&a;  //通过将short(2字节)强制类型转换成char单字节，b指向a的起始字节（低字节）
	//&a可以认为是个指向 unsigned int类型数据的指针，（char *）&a则把&a强制转换成 char *类型
	if( 0x11 == b)//低字节存的是数据的高字节数据
	{
		printf("da");//是大端模式
	}
	else
	{
		printf("xiao");//是小端模式
	}
	return 0;
}
```

## 3. 计算机网络
(1) TCP、UDP区别？

1. TCP面向连接（如打电话要先拨号建立连接）；UDP是无连接的，即发送数据之前不需要建立连接。
2. TCP提供可靠的服务，通过TCP连接传送的数据，无差错、不丢失、不重复、且按序达到，逻辑通信信道是全双工的可靠信道；UDP不保证可靠交付。
3. TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流；UDP是面向报文的。
4. UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率较低。
5. TCP连接点到点；UDP连接支持一对一，一对多，多对一和多对多的交互通信。
6. TCPS首部花销20字节，UDP8字节

(2) 网络里面为什么要有网络序的概念？是用来解决什么问题的？  

不同主机的主机字节序不同，不同在大、小端，所以不同主机存储字节的顺序可能不同，为了网络上所有的主机能够正确传输数据，规定了网络字节序（大端模式），不同的主机在传输数据时，进行相应的转换即可。（参考自郑浪）

## 4. 数据库
(1) 什么是存储引擎？MySQL不同存储引擎间有什么区别？

MySQL中的数据用各种不同的技术存储在文件（或者内存）中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。通过选择不同的技术，你能够获得额外的速度或者功能，从而改善你的应用的整体功能。

1. InnoDB ：5.5版本后Mysql的默认数据库，事务型数据库的首选引擎，支持事务安全表ACID，支持行级锁定和外键。如果需要对事务的完整性要求比较高（如：银行），要求实现并发控制（如：售票），都可选择InnDB。
2. MyISAM： 拥有较高的插入、查询速度，支持表级锁，但不支持事务，不支持外键，并发性低。

(2) 数据库mysql索引机制，为什么要用B+树？

1. 更少的IO次数：B+树的非叶节点只包含键，而不包含真实数据，因此每个节点存储的记录个数比B数多很多，因此B+树的高度更低，访问时所需要的IO次数更少。此外，由于每个节点存储的记录数更多，所以对访问局部性原理的利用更好，缓存命中率更高。
2. 更适于范围查询：B+树的范围查询，只需要对链表进行遍历即可。
3. 更稳定的查询效率：B树的查询时间复杂度在1到树高之间(分别对应记录在根节点和叶节点)，而B+树的查询复杂度则稳定为树高，因为所有数据都在叶节点。

## 5. 算法
(1) 反转字符串中的单词 III [Leetcode链接](https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/)  
> 给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。  
> 注意：在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。  
示例:
```c
输入: "Let's take LeetCode contest"
输出: "s'teL ekat edoCteeL tsetnoc" 
```
```c
#include <stdio.h>
#include <string.h>

inline void swap(char *x, char *y) {
    char a = *x;
    *x = *y;
    *y = a;
}

inline void rever(char *s, int start, int end) {
    int i = start, j = end;
    while(i<j) {
        swap(&s[i], &s[j]);
        i++;j--;
    }

}

char * reverseWords(char * s){
    int len = strlen(s), first=0, last=0, i;
    
    for(i=0; i<=len; i++){
        if(s[i] == ' ' || !s[i]) {
            rever(s, first, i-1);
            first = i + 1;
        }
    }

    return s;
}

int main()
{
	char s[] = "Let's take LeetCode contest";
	reverseWords(s);
	printf("%s", s);
}
```



(2) 三色排序 [Leetcode链接](https://leetcode-cn.com/problems/sort-colors/)
> 给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。  
> 注意:
不能使用代码库中的排序函数来解决这道题。  
示例:
```c
输入: [2,0,2,1,1,0]
输出: [0,0,1,1,2,2]
```