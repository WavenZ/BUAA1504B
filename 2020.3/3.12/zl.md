> 2020/3/12 第二天 坚持就是胜利

## 1. C/C++ 基础知识
(1) C++ 中空类对象sizeof的返回值是多少？为什么不能是0？

1 为了使得空类对象的地址唯一

(2) C++ 中多态是怎么实现的？ 

虚函数
## 2. 操作系统
(1) 扩容的时候内存用什么来分配？

(2) 怎么判断机器的大小端？

大小端与机器的处理器有关。
1. 大端模式：数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中。
2. 小端模式：数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中。

判断及其的大小端方法有很多：

1. 利用指针：
```cpp
bool isLittleEndian(){
    uint16_t a = 1;
    uint8_t* b = (uint8_t*)&a;
    return *b;
}
```
2. 利用联合体：
```cpp
bool isLittleEndian(){
  union{
      int16_t a = 1;
      int8_t b;
  }A;
  return A.b;
}
```
## 3. 计算机网络
(1) TCP、UDP区别？
1. TCP是面向连接的（在客户端和服务器之间传输数据之前要先建立连接），UDP是无连接的（发送数据之前不需要先建立连接）
2. TCP提供可靠的服务（通过TCP传输的数据。无差错，不丢失，不重复，且按序到达）；UDP提供面向事务的简单的不可靠的传输。
3. UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性比较高的通讯或广播通信。随着网速的提高，UDP使用越来越多。
4. 没一条TCP连接只能是点到点的，UDP支持一对一，一对多和多对多的交互通信。
5. TCP对系统资源要去比较多，UDP对系统资源要求比较少
6. UDP程序结构更加简单
7. TCP是流模式，UDP是数据报模式

(2) 网络里面为什么要有网络序的概念？是用来解决什么问题的？  
不同主机的字节序可能不同，如题2.(2)。因此，为了网络上所有的主机能够正确传输数据，规定了网络序（大端模式），不同的主机在传输数据时，进行相应的转换即可。

## 4. 数据库
(1) 什么是存储引擎？MySQL不同存储引擎间有什么区别？
MySQL中的数据用各种不同的技术存储在文件(或者内存)中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。通过选择不同的技术，你能够获得额外的速度或者功能，从而改善你的应用的整体功能。

1. InnoDB：这是MySQL 5.5或更高版本的默认存储引擎。它提供了事务安全(ACID兼容)表，支持外键引用完整性约束。它支持提交、回滚和紧急恢复功能来保护数据。它还支持行级锁定。当在多用户环境中使用时，它的“一致非锁定读取”提高了性能。它将数据存储在集群索引中，从而减少了基于主键的查询的I/O。
2. MyISAM：该存储引擎管理非事务性表，提供高速存储和检索，支持全文搜索。
3. MEMORY：提供内存中的表，以前称为堆。它在RAM中处理所有数据，以便比在磁盘上存储数据更快地访问。用于快速查找引用和其他相同的数据。
4. MERGE：将多个类似的MyISAM表分组为一个表，可以处理非事务性表，默认情况下包括这些表。
5. EXAMPLE：你可以使用此引擎创建表，但不能存储或获取数据。这样做的目的是教开发人员如何编写新的存储引擎。
6. ARCHIVE：用于存储大量数据，不支持索引。
7. CSV：在文本文件中以逗号分隔值格式存储数据。
8. BLACKHOLE：受要存储的数据，但始终返回空。
9. FEDERATED：将数据存储在远程数据库中。

(2) 数据库mysql索引机制，为什么要用B+树？
1. B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。
2. B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。
3. 由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。

## 5. 算法
(1) 反转字符串中的单词 III [Leetcode链接](https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/)  
> 给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。  
> 注意：在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。  
示例:
```c
输入: "Let's take LeetCode contest"
输出: "s'teL ekat edoCteeL tsetnoc" 
```
思路：先整体翻转，再翻转单个单词

```cpp
void Reverse(char* pBegin, char* pEnd)
{
    if(pBegin == nullptr || pEnd == nullptr)
        return;
    while(pBegin < pEnd)
    {
        char temp = *pBegin;
        *pBegin = *pEnd;
        *pEnd = temp;

        pBegin++, pEnd--;
    }
}
char* ReverseSentence(char* pDaat)
{
    if(pData == nullptr)
        return nullptr;
    
    char* pEnd = pData;
    while(*pEnd != '\0')
        pEnd++;
    pEnd--;
    // 翻转整个句子
    Reverse(pBegin, pEnd);

    // 翻转句子中的每个单词
    pBegin = pEnd = pData;
    while(*pBegin != '\0')
    {
        if(*pBegin == '')
        {
            pBegin ++;
            pEnd ++;
        }
        else if(*pEnd == '' || *pEnd == '\0')
        {
            Reverse(pBegin, --pEnd);
            pBegin = ++pEnd;
        }
        else{
            pEnd++;
        }
    }
    return pData;
}
```


(2) 三色排序 [Leetcode链接](https://leetcode-cn.com/problems/sort-colors/)
> 给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。  
> 注意:
不能使用代码库中的排序函数来解决这道题。  
示例:
```c
输入: [2,0,2,1,1,0]
输出: [0,0,1,1,2,2]
```
